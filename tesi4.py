# -*- coding: utf-8 -*-
"""tesi4.ipynb

Automatically generated by Colaboratory.

"""

from pandas import concat
from google.colab import drive
drive.mount('/content/gdrive')

!unzip "./gdrive/My Drive/datasets/dat1.gz.zip"
!gunzip ./dat1.gz
!unzip "./gdrive/My Drive/datasets/dat2.gz.zip"
!gunzip ./dat2.gz

from pandas import concat

from pandas import read_csv #importo da pandas il lettore di csv
import numpy as np #importo la libreria numpy e la rinomino np
from dateutil import parser #parsa la data per una più facile resa del codice
from matplotlib import pyplot

inputFile1 = "./dat1" 

labels1 = read_csv(inputFile1, nrows=1, header=0) #legge il csv
labels1 = labels1.columns.tolist()  #prende solo le colonne
        
data1 = read_csv(inputFile1, header=0) #legge il csvd


inputFile2 = "./dat2" 

labels2 = read_csv(inputFile2, nrows=1, header=0) #legge il csv
labels2 = labels2.columns.tolist()  #prende solo le colonne
        
data2 = read_csv(inputFile2, header=0) #legge il csvd

print(data1)
print(data2)

#unisco i due dataset
result = concat([data1, data2], axis=1, join_axes=[data1.index])
print(result)

#elimino colonne non rilevanti
result = result.drop(['ID', 'countrycode'], axis=1)

result = result.dropna() #elimino i campi NaN

result = result.drop(['datetime'], axis=1)

result.columns.tolist()

df = result['merchant'].value_counts().reset_index()
df.columns = ['merchant', 'count']
print(df)

#seleziono dalla colonna il venditore con le frequenze più alte
result = result.loc[result['merchant'] == 99510044]
print(result)



arraynp = np.array(result) #converto tutto in array numpy

#prendo le label relative alle colo
arraynplabels = arraynp[:, 6]
print( arraynplabels )

#creo un dataset senza le etichette
arraynp = arraynp[:, 0:6]
print(arraynp)


#converto i valori stringa in valori numerici per la rete neurale 

for i in range(len(arraynp)):
  if (arraynp[i,-1] == 'Desktop'):
    arraynp[i,-1] = 7
  elif (arraynp[i,-1] == 'Mobile'):
    arraynp[i,-1] = 8
  else: 
    arraynp[i,-1] = 9
    
  if (arraynp[i, -2] == 'Mozilla Firefox' or arraynp[i, -2] == 'Mozilla' or arraynp[i, -2] == 'Firefox'):
    arraynp[i,-2] = 6
  elif (arraynp[i,-2] == 'Google Chrome' or arraynp[i,-2] == 'Chrome'):
    arraynp[i,-2] = 1 
  elif (arraynp[i,-2] == 'InternetExplorer' or arraynp[i,-2] == 'Internet Explorer' or arraynp[i,-2] == 'IE'):
    arraynp[i,-2] = 2
  elif (arraynp[i,-2] == 'Opera'):
    arraynp[i,-2] = 3
  elif (arraynp[i,-2] == 'Safari'):
    arraynp[i,-2] = 4
  elif (arraynp[i,-2] == 'Edge'):
    arraynp[i,-2] = 5
    
    
#importo una libreria per trasformare i dati in un range da [0,1]
from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler(feature_range=(0, 1)) #seleziono il range in cui scalare i dati

arraynp = scaler.fit_transform(arraynp) #scalo i dati nel range selezionato
print(arraynp[0]) #controllo se sia andata a buon fine

#divido training e test set
from sklearn.model_selection import train_test_split

train, test = train_test_split(arraynp, test_size=0.2)
trainlabels, testlabels = train_test_split(arraynplabels, test_size=0.2)

print(test)
print(train)

from sklearn.model_selection import KFold
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout, Flatten, Embedding
from keras.optimizers import Adam, RMSprop, SGD
from pandas import DataFrame
from keras import regularizers
from keras.callbacks import ModelCheckpoint, History, EarlyStopping
import time
from matplotlib import pyplot
from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score
from sklearn.preprocessing import MinMaxScaler



class ReteNeurale:
  
  def avvioRete(self, traindata, trainlabels, validationData, validationLabels):
              
    timestr = time.strftime("%Y%m%d-%H%M%S") #l'ora attuale dell'esecuzione
    
    model = Sequential()
    model.add(Dense(10, input_dim=6, activation='relu', kernel_initializer='random_uniform',bias_initializer='zeros'))
    model.add(Dense(6, activation='relu'))
    model.add(Dense(1, activation='sigmoid'))
    
    adam = Adam(lr=0.00001, beta_1=0.9, beta_2=0.999, epsilon=None, decay=0.0, amsgrad=False)
    # Compile model
    model.compile(loss='binary_crossentropy', optimizer=adam, metrics=['acc'])
    # Fit the model        
    history = model.fit(traindata, 
                        trainlabels, 
                        epochs=200,
                        batch_size=256,
                        verbose=1,
                        validation_data=(validationData, validationLabels))
    
    self.faiplot(history, timestr)
    
    return model, history, timestr
    
    
  def faiplot(self, history, timestr):
    
    cartella = "./" 

    pyplot.plot(history.history['loss'], label='train')
    pyplot.plot(history.history['val_loss'], label='validation')
    pyplot.title('Loss')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Loss_' + timestr + '.png')
    pyplot.show()

    pyplot.plot(history.history['acc'], label='train')
    pyplot.plot(history.history['val_acc'], label='validation')
    pyplot.title('Accuracy')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Accuracy_' + timestr + '.png')
    pyplot.show()

nn = ReteNeurale()
model, history, timestring = nn.avvioRete(train, trainlabels, test, testlabels)

#predizioni sul test
predicted_probs = model.predict(test) #qui predico le probabilità per riga
predicted_labels = [int(round(x[0])) for x in predicted_probs] #etichettatura per riga

nn = ReteNeurale()
model, history, timestring = nn.avvioRete(train, trainlabels, test, testlabels)

#predizioni sul test
predicted_probs = model.predict(test) #qui predico le probabilità per riga
predicted_labels = [int(round(x[0])) for x in predicted_probs] #etichettatura per riga

intero = 0

for i in range(len(testlabels)):
  if(testlabels[i] == 1):
    intero += 1
    
print(intero)

predicted_labels

intero = 0

for i in range(len(predicted_labels)):
  if(predicted_labels[i] == 1):
    intero += 1
    
print(intero)

result = result.drop(['category', 'merchant'], axis=1)

arraynp = np.array(result) #converto tutto in array numpy

#prendo le label relative alle colo
arraynplabels = arraynp[:, -1]
print( arraynplabels )

#creo un dataset senza le etichette
arraynp = arraynp[:, 0:-1]
print(arraynp)


#converto i valori stringa in valori numerici per la rete neurale 

for i in range(len(arraynp)):
  if (arraynp[i,-1] == 'Desktop'):
    arraynp[i,-1] = 0
  elif (arraynp[i,-1] == 'Mobile'):
    arraynp[i,-1] = 1
  else: 
    arraynp[i,-1] = 2
    
  if (arraynp[i, -2] == 'Mozilla Firefox' or arraynp[i, -2] == 'Mozilla' or arraynp[i, -2] == 'Firefox'):
    arraynp[i,-2] = 0
  elif (arraynp[i,-2] == 'Google Chrome' or arraynp[i,-2] == 'Chrome'):
    arraynp[i,-2] = 1 
  elif (arraynp[i,-2] == 'InternetExplorer' or arraynp[i,-2] == 'Internet Explorer' or arraynp[i,-2] == 'IE'):
    arraynp[i,-2] = 2
  elif (arraynp[i,-2] == 'Opera'):
    arraynp[i,-2] = 3
  elif (arraynp[i,-2] == 'Safari'):
    arraynp[i,-2] = 4
  elif (arraynp[i,-2] == 'Edge'):
    arraynp[i,-2] = 5
    
    
#importo una libreria per trasformare i dati in un range da [0,1]
from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler(feature_range=(0, 1)) #seleziono il range in cui scalare i dati

arraynp = scaler.fit_transform(arraynp) #scalo i dati nel range selezionato
print(arraynp[0]) #controllo se sia andata a buon fine

#divido training e test set
from sklearn.model_selection import train_test_split

train, test = train_test_split(arraynp, test_size=0.2)
trainlabels, testlabels = train_test_split(arraynplabels, test_size=0.2)

print(test)
print(train)

train.shape

from sklearn.model_selection import KFold
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout, Flatten, Embedding
from keras.optimizers import Adam, RMSprop, SGD
from pandas import DataFrame
from keras import regularizers
from keras.callbacks import ModelCheckpoint, History, EarlyStopping
import time
from matplotlib import pyplot
from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score
from sklearn.preprocessing import MinMaxScaler



class ReteNeurale:
  
  def avvioRete(self, traindata, trainlabels, validationData, validationLabels):
              
    timestr = time.strftime("%Y%m%d-%H%M%S") #l'ora attuale dell'esecuzione
    
    model = Sequential()
    model.add(Dense(6, input_dim=4, activation='relu', kernel_initializer='random_uniform',bias_initializer='zeros'))
    model.add(Dense(4, activation='relu'))
    model.add(Dense(1, activation='sigmoid'))
    
    adam = Adam(lr=0.00001, beta_1=0.9, beta_2=0.999, epsilon=None, decay=0.0, amsgrad=False)
    # Compile model
    model.compile(loss='binary_crossentropy', optimizer=adam, metrics=['acc'])
    # Fit the model        
    history = model.fit(traindata, 
                        trainlabels, 
                        epochs=200,
                        batch_size=256,
                        verbose=1,
                        validation_data=(validationData, validationLabels))
    
    self.faiplot(history, timestr)
    
    return model, history, timestr
    
    
  def faiplot(self, history, timestr):
    
    cartella = "./" 

    pyplot.plot(history.history['loss'], label='train')
    pyplot.plot(history.history['val_loss'], label='validation')
    pyplot.title('Loss')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Loss_' + timestr + '.png')
    pyplot.show()

    pyplot.plot(history.history['acc'], label='train')
    pyplot.plot(history.history['val_acc'], label='validation')
    pyplot.title('Accuracy')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Accuracy_' + timestr + '.png')
    pyplot.show()

nn = ReteNeurale()
model, history, timestring = nn.avvioRete(train, trainlabels, test, testlabels)

#predizioni sul test
predicted_probs = model.predict(test) #qui predico le probabilità per riga
predicted_labels = [int(round(x[0])) for x in predicted_probs] #etichettatura per riga

predicted_labels

intero = 0

for i in range(len(predicted_labels)):
  if(predicted_labels[i] == 1):
    intero += 1
    
print(intero)

from sklearn.model_selection import KFold
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout, Flatten, Embedding
from keras.optimizers import Adam, RMSprop, SGD
from pandas import DataFrame
from keras import regularizers
from keras.callbacks import ModelCheckpoint, History, EarlyStopping
import time
from matplotlib import pyplot
from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score
from sklearn.preprocessing import MinMaxScaler



class ReteNeurale:
  
  def avvioRete(self, traindata, trainlabels, validationData, validationLabels):
              
    timestr = time.strftime("%Y%m%d-%H%M%S") #l'ora attuale dell'esecuzione
    
    model = Sequential()
    model.add(Dense(10, input_dim=6, activation='relu', kernel_initializer='random_uniform',bias_initializer='zeros'))
    model.add(Dropout(0.1))
    model.add(Dense(6, activation='relu'))
    model.add(Dense(1, activation='sigmoid'))
    
    adam = Adam(lr=0.00001, beta_1=0.9, beta_2=0.999, epsilon=None, decay=0.0, amsgrad=False)
    # Compile model
    model.compile(loss='binary_crossentropy', optimizer=adam, metrics=['acc'])
    # Fit the model        
    history = model.fit(traindata, 
                        trainlabels, 
                        epochs=100,
                        batch_size=512,
                        verbose=1,
                        validation_data=(validationData, validationLabels))
    
    self.faiplot(history, timestr)
    
    return model, history, timestr
    
    
  def faiplot(self, history, timestr):
    
    cartella = "./" 

    pyplot.plot(history.history['loss'], label='train')
    pyplot.plot(history.history['val_loss'], label='validation')
    pyplot.title('Loss')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Loss_' + timestr + '.png')
    pyplot.show()

    pyplot.plot(history.history['acc'], label='train')
    pyplot.plot(history.history['val_acc'], label='validation')
    pyplot.title('Accuracy')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Accuracy_' + timestr + '.png')
    pyplot.show()

nn = ReteNeurale()
model, history, timestring = nn.avvioRete(train, trainlabels, test, testlabels)

#predizioni sul test
predicted_probs = model.predict(test) #qui predico le probabilità per riga
predicted_labels = [int(round(x[0])) for x in predicted_probs] #etichettatura per riga

from sklearn.model_selection import KFold
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout, Flatten, Embedding
from keras.optimizers import Adam, RMSprop, SGD
from pandas import DataFrame
from keras import regularizers
from keras.callbacks import ModelCheckpoint, History, EarlyStopping
import time
from matplotlib import pyplot
from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score
from sklearn.preprocessing import MinMaxScaler



class ReteNeurale:
  
  def avvioRete(self, traindata, trainlabels, validationData, validationLabels):
              
    timestr = time.strftime("%Y%m%d-%H%M%S") #l'ora attuale dell'esecuzione
    
    model = Sequential()
    model.add(Dense(10, input_dim=6, activation='relu', kernel_initializer='random_uniform',bias_initializer='zeros'))
    model.add(Dropout(0.2))
    model.add(Dense(6, activation='relu'))
    model.add(Dense(1, activation='sigmoid'))
    
    adam = Adam(lr=0.00001, beta_1=0.9, beta_2=0.999, epsilon=None, decay=0.0, amsgrad=False)
    # Compile model
    model.compile(loss='binary_crossentropy', optimizer=adam, metrics=['acc'])
    # Fit the model        
    history = model.fit(traindata, 
                        trainlabels, 
                        epochs=100,
                        batch_size=512,
                        verbose=1,
                        validation_data=(validationData, validationLabels))
    
    self.faiplot(history, timestr)
    
    return model, history, timestr
    
    
  def faiplot(self, history, timestr):
    
    cartella = "./" 

    pyplot.plot(history.history['loss'], label='train')
    pyplot.plot(history.history['val_loss'], label='validation')
    pyplot.title('Loss')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Loss_' + timestr + '.png')
    pyplot.show()

    pyplot.plot(history.history['acc'], label='train')
    pyplot.plot(history.history['val_acc'], label='validation')
    pyplot.title('Accuracy')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Accuracy_' + timestr + '.png')
    pyplot.show()

nn = ReteNeurale()
model, history, timestring = nn.avvioRete(train, trainlabels, test, testlabels)

#predizioni sul test
predicted_probs = model.predict(test) #qui predico le probabilità per riga
predicted_labels = [int(round(x[0])) for x in predicted_probs] #etichettatura per riga

from sklearn.model_selection import KFold
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout, Flatten, Embedding
from keras.optimizers import Adam, RMSprop, SGD
from pandas import DataFrame
from keras import regularizers
from keras.callbacks import ModelCheckpoint, History, EarlyStopping
import time
from matplotlib import pyplot
from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score
from sklearn.preprocessing import MinMaxScaler



class ReteNeurale:
  
  def avvioRete(self, traindata, trainlabels, validationData, validationLabels):
              
    timestr = time.strftime("%Y%m%d-%H%M%S") #l'ora attuale dell'esecuzione
    
    model = Sequential()
    model.add(Dense(10, input_dim=6, activation='relu', kernel_initializer='random_uniform',bias_initializer='zeros'))
    model.add(Dropout(0.3))
    model.add(Dense(6, activation='relu'))
    model.add(Dense(1, activation='sigmoid'))
    
    adam = Adam(lr=0.00001, beta_1=0.9, beta_2=0.999, epsilon=None, decay=0.0, amsgrad=False)
    # Compile model
    model.compile(loss='binary_crossentropy', optimizer=adam, metrics=['acc'])
    # Fit the model        
    history = model.fit(traindata, 
                        trainlabels, 
                        epochs=100,
                        batch_size=512,
                        verbose=1,
                        validation_data=(validationData, validationLabels))
    
    self.faiplot(history, timestr)
    
    return model, history, timestr
    
    
  def faiplot(self, history, timestr):
    
    cartella = "./" 

    pyplot.plot(history.history['loss'], label='train')
    pyplot.plot(history.history['val_loss'], label='validation')
    pyplot.title('Loss')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Loss_' + timestr + '.png')
    pyplot.show()

    pyplot.plot(history.history['acc'], label='train')
    pyplot.plot(history.history['val_acc'], label='validation')
    pyplot.title('Accuracy')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Accuracy_' + timestr + '.png')
    pyplot.show()

nn = ReteNeurale()
model, history, timestring = nn.avvioRete(train, trainlabels, test, testlabels)

#predizioni sul test
predicted_probs = model.predict(test) #qui predico le probabilità per riga
predicted_labels = [int(round(x[0])) for x in predicted_probs] #etichettatura per riga

from sklearn.model_selection import KFold
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout, Flatten, Embedding
from keras.optimizers import Adam, RMSprop, SGD
from pandas import DataFrame
from keras import regularizers
from keras.callbacks import ModelCheckpoint, History, EarlyStopping
import time
from matplotlib import pyplot
from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score
from sklearn.preprocessing import MinMaxScaler



class ReteNeurale:
  
  def avvioRete(self, traindata, trainlabels, validationData, validationLabels):
              
    timestr = time.strftime("%Y%m%d-%H%M%S") #l'ora attuale dell'esecuzione
    
    model = Sequential()
    model.add(Dense(6, input_dim=6, activation='relu', kernel_initializer='random_uniform',bias_initializer='zeros'))
    model.add(Dropout(0.3))
    model.add(Dense(4, activation='relu'))
    model.add(Dense(1, activation='sigmoid'))
    
    adam = Adam(lr=0.00001, beta_1=0.9, beta_2=0.999, epsilon=None, decay=0.0, amsgrad=False)
    # Compile model
    model.compile(loss='binary_crossentropy', optimizer=adam, metrics=['acc'])
    # Fit the model        
    history = model.fit(traindata, 
                        trainlabels, 
                        epochs=100,
                        batch_size=512,
                        verbose=1,
                        validation_data=(validationData, validationLabels))
    
    self.faiplot(history, timestr)
    
    return model, history, timestr
    
    
  def faiplot(self, history, timestr):
    
    cartella = "./" 

    pyplot.plot(history.history['loss'], label='train')
    pyplot.plot(history.history['val_loss'], label='validation')
    pyplot.title('Loss')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Loss_' + timestr + '.png')
    pyplot.show()

    pyplot.plot(history.history['acc'], label='train')
    pyplot.plot(history.history['val_acc'], label='validation')
    pyplot.title('Accuracy')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Accuracy_' + timestr + '.png')
    pyplot.show()

nn = ReteNeurale()
model, history, timestring = nn.avvioRete(train, trainlabels, test, testlabels)

#predizioni sul test
predicted_probs = model.predict(test) #qui predico le probabilità per riga
predicted_labels = [int(round(x[0])) for x in predicted_probs] #etichettatura per riga

from sklearn.model_selection import KFold
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout, Flatten, Embedding
from keras.optimizers import Adam, RMSprop, SGD
from pandas import DataFrame
from keras import regularizers
from keras.callbacks import ModelCheckpoint, History, EarlyStopping
import time
from matplotlib import pyplot
from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score
from sklearn.preprocessing import MinMaxScaler



class ReteNeurale:
  
  def avvioRete(self, traindata, trainlabels, validationData, validationLabels):
              
    timestr = time.strftime("%Y%m%d-%H%M%S") #l'ora attuale dell'esecuzione
    
    model = Sequential()
    model.add(Dense(6, input_dim=6, activation='relu', kernel_initializer='random_uniform',bias_initializer='zeros'))
    model.add(Dropout(0.5))
    model.add(Dense(4, activation='relu'))
    model.add(Dropout(0.3))
    model.add(Dense(1, activation='sigmoid'))
    
    adam = Adam(lr=0.00001, beta_1=0.9, beta_2=0.999, epsilon=None, decay=0.0, amsgrad=False)
    # Compile model
    model.compile(loss='binary_crossentropy', optimizer=adam, metrics=['acc'])
    # Fit the model        
    history = model.fit(traindata, 
                        trainlabels, 
                        epochs=100,
                        batch_size=512,
                        verbose=1,
                        validation_data=(validationData, validationLabels))
    
    self.faiplot(history, timestr)
    
    return model, history, timestr
    
    
  def faiplot(self, history, timestr):
    
    cartella = "./" 

    pyplot.plot(history.history['loss'], label='train')
    pyplot.plot(history.history['val_loss'], label='validation')
    pyplot.title('Loss')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Loss_' + timestr + '.png')
    pyplot.show()

    pyplot.plot(history.history['acc'], label='train')
    pyplot.plot(history.history['val_acc'], label='validation')
    pyplot.title('Accuracy')
    pyplot.xlabel('Epochs')
    pyplot.legend()
    pyplot.savefig(cartella + 'Accuracy_' + timestr + '.png')
    pyplot.show()

nn = ReteNeurale()
model, history, timestring = nn.avvioRete(train, trainlabels, test, testlabels)

#predizioni sul test
predicted_probs = model.predict(test) #qui predico le probabilità per riga
predicted_labels = [int(round(x[0])) for x in predicted_probs] #etichettatura per riga